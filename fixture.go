package models

// THIS FILE GENERATED BY METIS

import (
	"time"

	"github.com/elos/d"
	"github.com/elos/d/builtin/mongo"
	"gopkg.in/mgo.v2/bson"
)

// this type def generated by metis
type Fixture struct {
	ActionableID   string       `json:"actionable_id" bson:"actionable_id"`
	ActionableKind string       `json:"actionable_kind" bson:"actionable_kind"`
	ActionsIDs     []string     `json:"actions_ids" bson:"actions_ids"`
	CreatedAt      *time.Time   `json:"created_at" bson:"created_at"`
	DateExceptions []*time.Time `json:"date_exceptions" bson:"date_exceptions"`
	Description    string       `json:"description" bson:"description"`
	EndTime        *time.Time   `json:"end_time" bson:"end_time"`
	EventableID    string       `json:"eventable_id" bson:"eventable_id"`
	EventableKind  string       `json:"eventable_kind" bson:"eventable_kind"`
	EventsIDs      []string     `json:"events_ids" bson:"events_ids"`
	Expires        *time.Time   `json:"expires" bson:"expires"`
	Id             string       `json:"id" bson:"_id,omitempty"`
	Label          bool         `json:"label" bson:"label"`
	Name           string       `json:"name" bson:"name"`
	Rank           int          `json:"rank" bson:"rank"`
	StartTime      *time.Time   `json:"start_time" bson:"start_time"`
	UpdatedAt      *time.Time   `json:"updated_at" bson:"updated_at"`
	UserID         string       `json:"user_id" bson:"user_id"`
}

func NewFixture() *Fixture {
	return &Fixture{}
}

// Kind is derived from the models package and is
// defined in type.go, shared among implementations
func (fixture *Fixture) Kind() d.Kind {
	return FixtureKind
}

// just returns itself for now
func (fixture *Fixture) Concerned() []d.ID {
	foo := make([]d.ID, 1)
	foo[0] = fixture.ID()
	return foo
}

func (fixture *Fixture) SetID(id d.ID) {
	fixture.Id = id.String()
}

func (fixture *Fixture) ID() d.ID {
	return d.ID(fixture.Id)
}

func (fixture *Fixture) SetActionable(actionable Actionable) error {
	fixture.ActionableID = actionable.ID().String()
	return nil
}

func (fixture *Fixture) Actionable(store d.Store) (Actionable, error) {
	if fixture.ActionableID == "" {
		return nil, ErrEmptyLink
	}

	m := ModelFor(d.Kind(fixture.ActionableKind))
	actionable := m.(Actionable)

	pid, _ := mongo.ParseObjectID(fixture.ActionableID)

	actionable.SetID(d.ID(pid.Hex()))
	return actionable, store.PopulateByID(actionable)

}

func (fixture *Fixture) IncludeAction(action *Action) {
	fixture.ActionsIDs = append(fixture.ActionsIDs, action.ID().String())
}

func (fixture *Fixture) ExcludeAction(action *Action) {
	tmp := make([]string, 0)
	id := action.ID().String()
	for _, s := range fixture.ActionsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	fixture.ActionsIDs = tmp
}

func (fixture *Fixture) ActionsIter(store d.Store) (d.ModelIterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(fixture.ActionsIDs), store), nil
}

func (fixture *Fixture) Actions(store d.Store) ([]*Action, error) {

	actions := make([]*Action, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(fixture.ActionsIDs), store)
	action := NewAction()
	for iter.Next(action) {
		actions = append(actions, action)
		action = NewAction()
	}
	return actions, nil
}

func (fixture *Fixture) SetEventable(eventable Eventable) error {
	fixture.EventableID = eventable.ID().String()
	return nil
}

func (fixture *Fixture) Eventable(store d.Store) (Eventable, error) {
	if fixture.EventableID == "" {
		return nil, ErrEmptyLink
	}

	m := ModelFor(d.Kind(fixture.EventableKind))
	eventable := m.(Eventable)

	pid, _ := mongo.ParseObjectID(fixture.EventableID)

	eventable.SetID(d.ID(pid.Hex()))
	return eventable, store.PopulateByID(eventable)

}

func (fixture *Fixture) IncludeEvent(event *Event) {
	fixture.EventsIDs = append(fixture.EventsIDs, event.ID().String())
}

func (fixture *Fixture) ExcludeEvent(event *Event) {
	tmp := make([]string, 0)
	id := event.ID().String()
	for _, s := range fixture.EventsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	fixture.EventsIDs = tmp
}

func (fixture *Fixture) EventsIter(store d.Store) (d.ModelIterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(fixture.EventsIDs), store), nil
}

func (fixture *Fixture) Events(store d.Store) ([]*Event, error) {

	events := make([]*Event, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(fixture.EventsIDs), store)
	event := NewEvent()
	for iter.Next(event) {
		events = append(events, event)
		event = NewEvent()
	}
	return events, nil
}

func (fixture *Fixture) SetUser(user *User) error {
	fixture.UserID = user.ID().String()
	return nil
}

func (fixture *Fixture) User(store d.Store) (*User, error) {
	if fixture.UserID == "" {
		return nil, ErrEmptyLink
	}

	user := NewUser()
	pid, _ := mongo.ParseObjectID(fixture.UserID)
	user.SetID(d.ID(pid.Hex()))
	return user, store.PopulateByID(user)

}

func (fixture *Fixture) GetBSON() (interface{}, error) {

	return struct {
		CreatedAt *time.Time `json:"created_at" bson:"created_at"`

		DateExceptions []*time.Time `json:"date_exceptions" bson:"date_exceptions"`

		Description string `json:"description" bson:"description"`

		EndTime *time.Time `json:"end_time" bson:"end_time"`

		Expires *time.Time `json:"expires" bson:"expires"`

		Id string `json:"id" bson:"_id,omitempty"`

		Label bool `json:"label" bson:"label"`

		Name string `json:"name" bson:"name"`

		Rank int `json:"rank" bson:"rank"`

		StartTime *time.Time `json:"start_time" bson:"start_time"`

		UpdatedAt *time.Time `json:"updated_at" bson:"updated_at"`

		ActionableID string `json:"actionable_id" bson:"actionable_id"`

		ActionableKind string `json:"actionable_kind" bson:"actionable_kind"`

		ActionsIDs []string `json:"actions_ids" bson:"actions_ids"`

		EventableID string `json:"eventable_id" bson:"eventable_id"`

		EventableKind string `json:"eventable_kind" bson:"eventable_kind"`

		EventsIDs []string `json:"events_ids" bson:"events_ids"`

		UserID string `json:"user_id" bson:"user_id"`
	}{

		CreatedAt: fixture.CreatedAt,

		DateExceptions: fixture.DateExceptions,

		Description: fixture.Description,

		EndTime: fixture.EndTime,

		Expires: fixture.Expires,

		Label: fixture.Label,

		Name: fixture.Name,

		Rank: fixture.Rank,

		StartTime: fixture.StartTime,

		UpdatedAt: fixture.UpdatedAt,

		ActionableID: fixture.ActionableID,

		ActionableKind: fixture.ActionableKind,

		ActionsIDs: fixture.ActionsIDs,

		EventableID: fixture.EventableID,

		EventableKind: fixture.EventableKind,

		EventsIDs: fixture.EventsIDs,

		UserID: fixture.UserID,
	}, nil

}

func (fixture *Fixture) SetBSON(raw bson.Raw) error {

	tmp := struct {
		CreatedAt *time.Time `json:"created_at" bson:"created_at"`

		DateExceptions []*time.Time `json:"date_exceptions" bson:"date_exceptions"`

		Description string `json:"description" bson:"description"`

		EndTime *time.Time `json:"end_time" bson:"end_time"`

		Expires *time.Time `json:"expires" bson:"expires"`

		Id bson.ObjectId `json:"id" bson:"_id,omitempty"`

		Label bool `json:"label" bson:"label"`

		Name string `json:"name" bson:"name"`

		Rank int `json:"rank" bson:"rank"`

		StartTime *time.Time `json:"start_time" bson:"start_time"`

		UpdatedAt *time.Time `json:"updated_at" bson:"updated_at"`

		ActionableID string `json:"actionable_id" bson:"actionable_id"`

		ActionableKind string `json:"actionable_kind" bson:"actionable_kind"`

		ActionsIDs []string `json:"actions_ids" bson:"actions_ids"`

		EventableID string `json:"eventable_id" bson:"eventable_id"`

		EventableKind string `json:"eventable_kind" bson:"eventable_kind"`

		EventsIDs []string `json:"events_ids" bson:"events_ids"`

		UserID string `json:"user_id" bson:"user_id"`
	}{}

	err := raw.Unmarshal(&tmp)
	if err != nil {
		return err
	}

	fixture.CreatedAt = tmp.CreatedAt

	fixture.DateExceptions = tmp.DateExceptions

	fixture.Description = tmp.Description

	fixture.EndTime = tmp.EndTime

	fixture.Expires = tmp.Expires

	fixture.Id = tmp.Id.Hex()

	fixture.Label = tmp.Label

	fixture.Name = tmp.Name

	fixture.Rank = tmp.Rank

	fixture.StartTime = tmp.StartTime

	fixture.UpdatedAt = tmp.UpdatedAt

	fixture.ActionableID = tmp.ActionableID

	fixture.ActionableKind = tmp.ActionableKind

	fixture.ActionsIDs = tmp.ActionsIDs

	fixture.EventableID = tmp.EventableID

	fixture.EventableKind = tmp.EventableKind

	fixture.EventsIDs = tmp.EventsIDs

	fixture.UserID = tmp.UserID

	return nil

}
