package models

import (
	"time"

	"github.com/elos/data"
	"github.com/elos/data/builtin/mongo"
	"github.com/elos/metis"
	"gopkg.in/mgo.v2/bson"
)

// THIS FILE GENERATED BY METIS

// this type def generated by metis
type Credential struct {
	CreatedAt   time.Time `json:"created_at" bson:"created_at"`
	DeletedAt   time.Time `json:"deleted_at" bson:"deleted_at"`
	Id          string    `json:"id" bson:"_id,omitempty"`
	Name        string    `json:"name" bson:"name"`
	OwnerId     string    `json:"owner_id" bson:"owner_id"`
	Private     string    `json:"private" bson:"private"`
	Public      string    `json:"public" bson:"public"`
	SessionsIds []string  `json:"sessions_ids" bson:"sessions_ids"`
	Spec        string    `json:"spec" bson:"spec"`
	UpdatedAt   time.Time `json:"updated_at" bson:"updated_at"`
}

func NewCredential() *Credential {
	return &Credential{}
}

func FindCredential(db data.DB, id data.ID) (*Credential, error) {

	credential := NewCredential()
	credential.SetID(id)

	return credential, db.PopulateByID(credential)

}

// Kind is derived from the models package and is
// defined in type.go, shared among implementations
func (credential *Credential) Kind() data.Kind {
	return CredentialKind
}

// just returns itself for now
func (credential *Credential) Concerned() []data.ID {
	foo := make([]data.ID, 1)
	foo[0] = credential.ID()
	return foo
}

func (credential *Credential) SetID(id data.ID) {
	credential.Id = id.String()
}

func (credential *Credential) ID() data.ID {
	return data.ID(credential.Id)
}

func (credential *Credential) SetOwner(userArgument *User) error {
	credential.OwnerId = userArgument.ID().String()
	return nil
}

func (credential *Credential) Owner(db data.DB) (*User, error) {
	if credential.OwnerId == "" {
		return nil, ErrEmptyLink
	}

	userArgument := NewUser()
	id, _ := db.ParseID(credential.OwnerId)
	userArgument.SetID(id)
	return userArgument, db.PopulateByID(userArgument)

}

func (credential *Credential) OwnerOrCreate(db data.DB) (*User, error) {
	user, err := credential.Owner(db)

	if err == ErrEmptyLink {
		user := NewUser()
		user.SetID(db.NewID())
		if err := credential.SetOwner(user); err != nil {
			return nil, err
		}

		if err := db.Save(user); err != nil {
			return nil, err
		}

		if err := db.Save(credential); err != nil {
			return nil, err
		}

		return user, nil
	} else {
		return user, err
	}
}

func (credential *Credential) IncludeSession(session *Session) {
	otherID := session.ID().String()
	for i := range credential.SessionsIds {
		if credential.SessionsIds[i] == otherID {
			return
		}
	}
	credential.SessionsIds = append(credential.SessionsIds, otherID)
}

func (credential *Credential) ExcludeSession(session *Session) {
	tmp := make([]string, 0)
	id := session.ID().String()
	for _, s := range credential.SessionsIds {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	credential.SessionsIds = tmp
}

func (credential *Credential) SessionsIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(credential.SessionsIds), db), nil
}

func (credential *Credential) Sessions(db data.DB) (sessions []*Session, err error) {
	sessions = make([]*Session, len(credential.SessionsIds))
	session := NewSession()
	for i, id := range credential.SessionsIds {
		session.Id = id
		if err = db.PopulateByID(session); err != nil {
			return
		}

		sessions[i] = session
		session = NewSession()
	}

	return
}

// BSON {{{
func (credential *Credential) GetBSON() (interface{}, error) {

	return struct {
		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		DeletedAt time.Time `json:"deleted_at" bson:"deleted_at"`

		Id string `json:"id" bson:"_id,omitempty"`

		Name string `json:"name" bson:"name"`

		Private string `json:"private" bson:"private"`

		Public string `json:"public" bson:"public"`

		Spec string `json:"spec" bson:"spec"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		OwnerId string `json:"owner_id" bson:"owner_id"`

		SessionsIds []string `json:"sessions_ids" bson:"sessions_ids"`
	}{

		CreatedAt: credential.CreatedAt,

		DeletedAt: credential.DeletedAt,

		Name: credential.Name,

		Private: credential.Private,

		Public: credential.Public,

		Spec: credential.Spec,

		UpdatedAt: credential.UpdatedAt,

		OwnerId: credential.OwnerId,

		SessionsIds: credential.SessionsIds,
	}, nil

}

func (credential *Credential) SetBSON(raw bson.Raw) error {

	tmp := struct {
		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		DeletedAt time.Time `json:"deleted_at" bson:"deleted_at"`

		Id bson.ObjectId `json:"id" bson:"_id,omitempty"`

		Name string `json:"name" bson:"name"`

		Private string `json:"private" bson:"private"`

		Public string `json:"public" bson:"public"`

		Spec string `json:"spec" bson:"spec"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		OwnerId string `json:"owner_id" bson:"owner_id"`

		SessionsIds []string `json:"sessions_ids" bson:"sessions_ids"`
	}{}

	err := raw.Unmarshal(&tmp)
	if err != nil {
		return err
	}

	credential.CreatedAt = tmp.CreatedAt

	credential.DeletedAt = tmp.DeletedAt

	credential.Id = tmp.Id.Hex()

	credential.Name = tmp.Name

	credential.Private = tmp.Private

	credential.Public = tmp.Public

	credential.Spec = tmp.Spec

	credential.UpdatedAt = tmp.UpdatedAt

	credential.OwnerId = tmp.OwnerId

	credential.SessionsIds = tmp.SessionsIds

	return nil

}

// BSON }}}

func (credential *Credential) FromStructure(structure map[string]interface{}) {

	if val, ok := structure["id"]; ok {
		credential.Id = val.(string)
	}

	if val, ok := structure["created_at"]; ok {
		credential.CreatedAt = val.(time.Time)
	}

	if val, ok := structure["updated_at"]; ok {
		credential.UpdatedAt = val.(time.Time)
	}

	if val, ok := structure["deleted_at"]; ok {
		credential.DeletedAt = val.(time.Time)
	}

	if val, ok := structure["public"]; ok {
		credential.Public = val.(string)
	}

	if val, ok := structure["private"]; ok {
		credential.Private = val.(string)
	}

	if val, ok := structure["spec"]; ok {
		credential.Spec = val.(string)
	}

	if val, ok := structure["name"]; ok {
		credential.Name = val.(string)
	}

	if val, ok := structure["owner_id"]; ok {
		credential.OwnerId = val.(string)
	}

	if val, ok := structure["sessions_ids"]; ok {
		credential.SessionsIds = val.([]string)
	}

}

var CredentialStructure = map[string]metis.Primitive{

	"spec": 3,

	"name": 3,

	"id": 9,

	"created_at": 4,

	"updated_at": 4,

	"deleted_at": 4,

	"public": 3,

	"private": 3,

	"owner_id": 9,

	"sessions_ids": 10,
}
