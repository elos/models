package models

import (
	"time"

	"github.com/elos/data"
	"github.com/elos/metis"
	"gopkg.in/mgo.v2/bson"
)

// THIS FILE GENERATED BY METIS

// this type def generated by metis
type Recurrence struct {
	ByDay      []int       `json:"by_day" bson:"by_day"`
	ByHour     []int       `json:"by_hour" bson:"by_hour"`
	ByMonthDay []int       `json:"by_month_day" bson:"by_month_day"`
	ByMonthNum []int       `json:"by_month_num" bson:"by_month_num"`
	BySecond   []int       `json:"by_second" bson:"by_second"`
	BySetPos   []int       `json:"by_set_pos" bson:"by_set_pos"`
	ByWeekNum  []int       `json:"by_week_num" bson:"by_week_num"`
	ByYearDay  []int       `json:"by_year_day" bson:"by_year_day"`
	Count      int         `json:"count" bson:"count"`
	CreatedAt  time.Time   `json:"created_at" bson:"created_at"`
	DeletedAt  time.Time   `json:"deleted_at" bson:"deleted_at"`
	Exclusions []time.Time `json:"exclusions" bson:"exclusions"`
	Frequency  string      `json:"frequency" bson:"frequency"`
	Id         string      `json:"id" bson:"_id,omitempty"`
	Inclusions []time.Time `json:"inclusions" bson:"inclusions"`
	Interval   int         `json:"interval" bson:"interval"`
	Limit      time.Time   `json:"limit" bson:"limit"`
	OwnerId    string      `json:"owner_id" bson:"owner_id"`
	Start      time.Time   `json:"start" bson:"start"`
	Until      time.Time   `json:"until" bson:"until"`
	UpdatedAt  time.Time   `json:"updated_at" bson:"updated_at"`
	WeekStart  int         `json:"week_start" bson:"week_start"`
}

func NewRecurrence() *Recurrence {
	return &Recurrence{}
}

func FindRecurrence(db data.DB, id data.ID) (*Recurrence, error) {

	recurrence := NewRecurrence()
	recurrence.SetID(id)

	return recurrence, db.PopulateByID(recurrence)

}

// Kind is derived from the models package and is
// defined in type.go, shared among implementations
func (recurrence *Recurrence) Kind() data.Kind {
	return RecurrenceKind
}

// just returns itself for now
func (recurrence *Recurrence) Concerned() []data.ID {
	foo := make([]data.ID, 1)
	foo[0] = recurrence.ID()
	return foo
}

func (recurrence *Recurrence) SetID(id data.ID) {
	recurrence.Id = id.String()
}

func (recurrence *Recurrence) ID() data.ID {
	return data.ID(recurrence.Id)
}

func (recurrence *Recurrence) SetOwner(userArgument *User) error {
	recurrence.OwnerId = userArgument.ID().String()
	return nil
}

func (recurrence *Recurrence) Owner(db data.DB) (*User, error) {
	if recurrence.OwnerId == "" {
		return nil, ErrEmptyLink
	}

	userArgument := NewUser()
	id, _ := db.ParseID(recurrence.OwnerId)
	userArgument.SetID(id)
	return userArgument, db.PopulateByID(userArgument)

}

func (recurrence *Recurrence) OwnerOrCreate(db data.DB) (*User, error) {
	user, err := recurrence.Owner(db)

	if err == ErrEmptyLink {
		user := NewUser()
		user.SetID(db.NewID())
		if err := recurrence.SetOwner(user); err != nil {
			return nil, err
		}

		if err := db.Save(user); err != nil {
			return nil, err
		}

		if err := db.Save(recurrence); err != nil {
			return nil, err
		}

		return user, nil
	} else {
		return user, err
	}
}

// BSON {{{
func (recurrence *Recurrence) GetBSON() (interface{}, error) {

	return struct {
		ByDay []int `json:"by_day" bson:"by_day"`

		ByHour []int `json:"by_hour" bson:"by_hour"`

		ByMonthDay []int `json:"by_month_day" bson:"by_month_day"`

		ByMonthNum []int `json:"by_month_num" bson:"by_month_num"`

		BySecond []int `json:"by_second" bson:"by_second"`

		BySetPos []int `json:"by_set_pos" bson:"by_set_pos"`

		ByWeekNum []int `json:"by_week_num" bson:"by_week_num"`

		ByYearDay []int `json:"by_year_day" bson:"by_year_day"`

		Count int `json:"count" bson:"count"`

		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		DeletedAt time.Time `json:"deleted_at" bson:"deleted_at"`

		Exclusions []time.Time `json:"exclusions" bson:"exclusions"`

		Frequency string `json:"frequency" bson:"frequency"`

		Id string `json:"id" bson:"_id,omitempty"`

		Inclusions []time.Time `json:"inclusions" bson:"inclusions"`

		Interval int `json:"interval" bson:"interval"`

		Limit time.Time `json:"limit" bson:"limit"`

		Start time.Time `json:"start" bson:"start"`

		Until time.Time `json:"until" bson:"until"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		WeekStart int `json:"week_start" bson:"week_start"`

		OwnerId string `json:"owner_id" bson:"owner_id"`
	}{

		ByDay: recurrence.ByDay,

		ByHour: recurrence.ByHour,

		ByMonthDay: recurrence.ByMonthDay,

		ByMonthNum: recurrence.ByMonthNum,

		BySecond: recurrence.BySecond,

		BySetPos: recurrence.BySetPos,

		ByWeekNum: recurrence.ByWeekNum,

		ByYearDay: recurrence.ByYearDay,

		Count: recurrence.Count,

		CreatedAt: recurrence.CreatedAt,

		DeletedAt: recurrence.DeletedAt,

		Exclusions: recurrence.Exclusions,

		Frequency: recurrence.Frequency,

		Inclusions: recurrence.Inclusions,

		Interval: recurrence.Interval,

		Limit: recurrence.Limit,

		Start: recurrence.Start,

		Until: recurrence.Until,

		UpdatedAt: recurrence.UpdatedAt,

		WeekStart: recurrence.WeekStart,

		OwnerId: recurrence.OwnerId,
	}, nil

}

func (recurrence *Recurrence) SetBSON(raw bson.Raw) error {

	tmp := struct {
		ByDay []int `json:"by_day" bson:"by_day"`

		ByHour []int `json:"by_hour" bson:"by_hour"`

		ByMonthDay []int `json:"by_month_day" bson:"by_month_day"`

		ByMonthNum []int `json:"by_month_num" bson:"by_month_num"`

		BySecond []int `json:"by_second" bson:"by_second"`

		BySetPos []int `json:"by_set_pos" bson:"by_set_pos"`

		ByWeekNum []int `json:"by_week_num" bson:"by_week_num"`

		ByYearDay []int `json:"by_year_day" bson:"by_year_day"`

		Count int `json:"count" bson:"count"`

		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		DeletedAt time.Time `json:"deleted_at" bson:"deleted_at"`

		Exclusions []time.Time `json:"exclusions" bson:"exclusions"`

		Frequency string `json:"frequency" bson:"frequency"`

		Id bson.ObjectId `json:"id" bson:"_id,omitempty"`

		Inclusions []time.Time `json:"inclusions" bson:"inclusions"`

		Interval int `json:"interval" bson:"interval"`

		Limit time.Time `json:"limit" bson:"limit"`

		Start time.Time `json:"start" bson:"start"`

		Until time.Time `json:"until" bson:"until"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		WeekStart int `json:"week_start" bson:"week_start"`

		OwnerId string `json:"owner_id" bson:"owner_id"`
	}{}

	err := raw.Unmarshal(&tmp)
	if err != nil {
		return err
	}

	recurrence.ByDay = tmp.ByDay

	recurrence.ByHour = tmp.ByHour

	recurrence.ByMonthDay = tmp.ByMonthDay

	recurrence.ByMonthNum = tmp.ByMonthNum

	recurrence.BySecond = tmp.BySecond

	recurrence.BySetPos = tmp.BySetPos

	recurrence.ByWeekNum = tmp.ByWeekNum

	recurrence.ByYearDay = tmp.ByYearDay

	recurrence.Count = tmp.Count

	recurrence.CreatedAt = tmp.CreatedAt

	recurrence.DeletedAt = tmp.DeletedAt

	recurrence.Exclusions = tmp.Exclusions

	recurrence.Frequency = tmp.Frequency

	recurrence.Id = tmp.Id.Hex()

	recurrence.Inclusions = tmp.Inclusions

	recurrence.Interval = tmp.Interval

	recurrence.Limit = tmp.Limit

	recurrence.Start = tmp.Start

	recurrence.Until = tmp.Until

	recurrence.UpdatedAt = tmp.UpdatedAt

	recurrence.WeekStart = tmp.WeekStart

	recurrence.OwnerId = tmp.OwnerId

	return nil

}

// BSON }}}

func (recurrence *Recurrence) FromStructure(structure map[string]interface{}) {

	if val, ok := structure["deleted_at"]; ok {
		recurrence.DeletedAt = val.(time.Time)
	}

	if val, ok := structure["exclusions"]; ok {
		recurrence.Exclusions = val.([]time.Time)
	}

	if val, ok := structure["created_at"]; ok {
		recurrence.CreatedAt = val.(time.Time)
	}

	if val, ok := structure["updated_at"]; ok {
		recurrence.UpdatedAt = val.(time.Time)
	}

	if val, ok := structure["until"]; ok {
		recurrence.Until = val.(time.Time)
	}

	if val, ok := structure["count"]; ok {
		recurrence.Count = val.(int)
	}

	if val, ok := structure["by_hour"]; ok {
		recurrence.ByHour = val.([]int)
	}

	if val, ok := structure["start"]; ok {
		recurrence.Start = val.(time.Time)
	}

	if val, ok := structure["by_second"]; ok {
		recurrence.BySecond = val.([]int)
	}

	if val, ok := structure["by_day"]; ok {
		recurrence.ByDay = val.([]int)
	}

	if val, ok := structure["by_year_day"]; ok {
		recurrence.ByYearDay = val.([]int)
	}

	if val, ok := structure["by_set_pos"]; ok {
		recurrence.BySetPos = val.([]int)
	}

	if val, ok := structure["week_start"]; ok {
		recurrence.WeekStart = val.(int)
	}

	if val, ok := structure["limit"]; ok {
		recurrence.Limit = val.(time.Time)
	}

	if val, ok := structure["id"]; ok {
		recurrence.Id = val.(string)
	}

	if val, ok := structure["frequency"]; ok {
		recurrence.Frequency = val.(string)
	}

	if val, ok := structure["interval"]; ok {
		recurrence.Interval = val.(int)
	}

	if val, ok := structure["by_month_day"]; ok {
		recurrence.ByMonthDay = val.([]int)
	}

	if val, ok := structure["by_week_num"]; ok {
		recurrence.ByWeekNum = val.([]int)
	}

	if val, ok := structure["by_month_num"]; ok {
		recurrence.ByMonthNum = val.([]int)
	}

	if val, ok := structure["inclusions"]; ok {
		recurrence.Inclusions = val.([]time.Time)
	}

	if val, ok := structure["owner_id"]; ok {
		recurrence.OwnerId = val.(string)
	}

}

var RecurrenceStructure = map[string]metis.Primitive{

	"start": 4,

	"by_second": 6,

	"by_day": 6,

	"by_year_day": 6,

	"by_set_pos": 6,

	"week_start": 1,

	"inclusions": 8,

	"limit": 4,

	"id": 9,

	"frequency": 3,

	"interval": 1,

	"by_month_day": 6,

	"by_week_num": 6,

	"by_month_num": 6,

	"deleted_at": 4,

	"exclusions": 8,

	"created_at": 4,

	"updated_at": 4,

	"until": 4,

	"count": 1,

	"by_hour": 6,

	"owner_id": 9,
}
