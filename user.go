package models

import (
	"time"

	"github.com/elos/data"
	"github.com/elos/data/builtin/mongo"
	"gopkg.in/mgo.v2/bson"
)

// THIS FILE GENERATED BY METIS

// this type def generated by metis
type User struct {
	AuthorizationsIDs []string  `json:"authorizations_ids" bson:"authorizations_ids"`
	CreatedAt         time.Time `json:"created_at" bson:"created_at"`
	CredentialsIDs    []string  `json:"credentials_ids" bson:"credentials_ids"`
	GroupsIDs         []string  `json:"groups_ids" bson:"groups_ids"`
	Id                string    `json:"id" bson:"_id,omitempty"`
	Password          string    `json:"password" bson:"password"`
	SessionsIDs       []string  `json:"sessions_ids" bson:"sessions_ids"`
	UpdatedAt         time.Time `json:"updated_at" bson:"updated_at"`
}

func NewUser() *User {
	return &User{}
}

// Kind is derived from the models package and is
// defined in type.go, shared among implementations
func (user *User) Kind() data.Kind {
	return UserKind
}

// just returns itself for now
func (user *User) Concerned() []data.ID {
	foo := make([]data.ID, 1)
	foo[0] = user.ID()
	return foo
}

func (user *User) SetID(id data.ID) {
	user.Id = id.String()
}

func (user *User) ID() data.ID {
	return data.ID(user.Id)
}

func (user *User) IncludeAuthorization(authorization *Group) {
	user.AuthorizationsIDs = append(user.AuthorizationsIDs, authorization.ID().String())
}

func (user *User) ExcludeAuthorization(authorization *Group) {
	tmp := make([]string, 0)
	id := authorization.ID().String()
	for _, s := range user.AuthorizationsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	user.AuthorizationsIDs = tmp
}

func (user *User) AuthorizationsIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(user.AuthorizationsIDs), db), nil
}

func (user *User) Authorizations(db data.DB) ([]*Group, error) {

	authorizations := make([]*Group, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(user.AuthorizationsIDs), db)
	authorization := NewGroup()
	for iter.Next(authorization) {
		authorizations = append(authorizations, authorization)
		authorization = NewGroup()
	}
	return authorizations, nil
}

func (user *User) IncludeCredential(credential *Credential) {
	user.CredentialsIDs = append(user.CredentialsIDs, credential.ID().String())
}

func (user *User) ExcludeCredential(credential *Credential) {
	tmp := make([]string, 0)
	id := credential.ID().String()
	for _, s := range user.CredentialsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	user.CredentialsIDs = tmp
}

func (user *User) CredentialsIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(user.CredentialsIDs), db), nil
}

func (user *User) Credentials(db data.DB) ([]*Credential, error) {

	credentials := make([]*Credential, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(user.CredentialsIDs), db)
	credential := NewCredential()
	for iter.Next(credential) {
		credentials = append(credentials, credential)
		credential = NewCredential()
	}
	return credentials, nil
}

func (user *User) IncludeGroup(group *Group) {
	user.GroupsIDs = append(user.GroupsIDs, group.ID().String())
}

func (user *User) ExcludeGroup(group *Group) {
	tmp := make([]string, 0)
	id := group.ID().String()
	for _, s := range user.GroupsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	user.GroupsIDs = tmp
}

func (user *User) GroupsIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(user.GroupsIDs), db), nil
}

func (user *User) Groups(db data.DB) ([]*Group, error) {

	groups := make([]*Group, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(user.GroupsIDs), db)
	group := NewGroup()
	for iter.Next(group) {
		groups = append(groups, group)
		group = NewGroup()
	}
	return groups, nil
}

func (user *User) IncludeSession(session *Session) {
	user.SessionsIDs = append(user.SessionsIDs, session.ID().String())
}

func (user *User) ExcludeSession(session *Session) {
	tmp := make([]string, 0)
	id := session.ID().String()
	for _, s := range user.SessionsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	user.SessionsIDs = tmp
}

func (user *User) SessionsIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(user.SessionsIDs), db), nil
}

func (user *User) Sessions(db data.DB) ([]*Session, error) {

	sessions := make([]*Session, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(user.SessionsIDs), db)
	session := NewSession()
	for iter.Next(session) {
		sessions = append(sessions, session)
		session = NewSession()
	}
	return sessions, nil
}

// BSON {{{
func (user *User) GetBSON() (interface{}, error) {

	return struct {
		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		Id string `json:"id" bson:"_id,omitempty"`

		Password string `json:"password" bson:"password"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		AuthorizationsIDs []string `json:"authorizations_ids" bson:"authorizations_ids"`

		CredentialsIDs []string `json:"credentials_ids" bson:"credentials_ids"`

		GroupsIDs []string `json:"groups_ids" bson:"groups_ids"`

		SessionsIDs []string `json:"sessions_ids" bson:"sessions_ids"`
	}{

		CreatedAt: user.CreatedAt,

		Password: user.Password,

		UpdatedAt: user.UpdatedAt,

		AuthorizationsIDs: user.AuthorizationsIDs,

		CredentialsIDs: user.CredentialsIDs,

		GroupsIDs: user.GroupsIDs,

		SessionsIDs: user.SessionsIDs,
	}, nil

}

func (user *User) SetBSON(raw bson.Raw) error {

	tmp := struct {
		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		Id bson.ObjectId `json:"id" bson:"_id,omitempty"`

		Password string `json:"password" bson:"password"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		AuthorizationsIDs []string `json:"authorizations_ids" bson:"authorizations_ids"`

		CredentialsIDs []string `json:"credentials_ids" bson:"credentials_ids"`

		GroupsIDs []string `json:"groups_ids" bson:"groups_ids"`

		SessionsIDs []string `json:"sessions_ids" bson:"sessions_ids"`
	}{}

	err := raw.Unmarshal(&tmp)
	if err != nil {
		return err
	}

	user.CreatedAt = tmp.CreatedAt

	user.Id = tmp.Id.Hex()

	user.Password = tmp.Password

	user.UpdatedAt = tmp.UpdatedAt

	user.AuthorizationsIDs = tmp.AuthorizationsIDs

	user.CredentialsIDs = tmp.CredentialsIDs

	user.GroupsIDs = tmp.GroupsIDs

	user.SessionsIDs = tmp.SessionsIDs

	return nil

}

// BSON }}}
