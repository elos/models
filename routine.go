package models

import (
	"time"

	"github.com/elos/data"
	"github.com/elos/data/builtin/mongo"
	"gopkg.in/mgo.v2/bson"
)

// THIS FILE GENERATED BY METIS

// this type def generated by metis
type Routine struct {
	ActionsIDs        []string   `json:"actions_ids" bson:"actions_ids"`
	CompletedTasksIDs []string   `json:"completed_tasks_ids" bson:"completed_tasks_ids"`
	CreatedAt         *time.Time `json:"created_at" bson:"created_at"`
	CurrentActionID   string     `json:"current_action_id" bson:"current_action_id"`
	EndTime           *time.Time `json:"end_time" bson:"end_time"`
	Id                string     `json:"id" bson:"_id,omitempty"`
	Name              string     `json:"name" bson:"name"`
	StartTime         *time.Time `json:"start_time" bson:"start_time"`
	TasksIDs          []string   `json:"tasks_ids" bson:"tasks_ids"`
	UpdatedAt         *time.Time `json:"updated_at" bson:"updated_at"`
	UserID            string     `json:"user_id" bson:"user_id"`
}

func NewRoutine() *Routine {
	return &Routine{}
}

// Kind is derived from the models package and is
// defined in type.go, shared among implementations
func (routine *Routine) Kind() data.Kind {
	return RoutineKind
}

// just returns itself for now
func (routine *Routine) Concerned() []data.ID {
	foo := make([]data.ID, 1)
	foo[0] = routine.ID()
	return foo
}

func (routine *Routine) SetID(id data.ID) {
	routine.Id = id.String()
}

func (routine *Routine) ID() data.ID {
	return data.ID(routine.Id)
}

func (routine *Routine) IncludeAction(action *Action) {
	routine.ActionsIDs = append(routine.ActionsIDs, action.ID().String())
}

func (routine *Routine) ExcludeAction(action *Action) {
	tmp := make([]string, 0)
	id := action.ID().String()
	for _, s := range routine.ActionsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	routine.ActionsIDs = tmp
}

func (routine *Routine) ActionsIter(store data.Store) (data.ModelIterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.ActionsIDs), store), nil
}

func (routine *Routine) Actions(store data.Store) ([]*Action, error) {

	actions := make([]*Action, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.ActionsIDs), store)
	action := NewAction()
	for iter.Next(action) {
		actions = append(actions, action)
		action = NewAction()
	}
	return actions, nil
}

func (routine *Routine) IncludeCompletedTask(completedTask *Task) {
	routine.CompletedTasksIDs = append(routine.CompletedTasksIDs, completedTask.ID().String())
}

func (routine *Routine) ExcludeCompletedTask(completedTask *Task) {
	tmp := make([]string, 0)
	id := completedTask.ID().String()
	for _, s := range routine.CompletedTasksIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	routine.CompletedTasksIDs = tmp
}

func (routine *Routine) CompletedTasksIter(store data.Store) (data.ModelIterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.CompletedTasksIDs), store), nil
}

func (routine *Routine) CompletedTasks(store data.Store) ([]*Task, error) {

	completed_tasks := make([]*Task, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.CompletedTasksIDs), store)
	completed_task := NewTask()
	for iter.Next(completed_task) {
		completed_tasks = append(completed_tasks, completed_task)
		completed_task = NewTask()
	}
	return completed_tasks, nil
}

func (routine *Routine) SetCurrentAction(action *Action) error {
	routine.CurrentActionID = action.ID().String()
	return nil
}

func (routine *Routine) CurrentAction(store data.Store) (*Action, error) {
	if routine.CurrentActionID == "" {
		return nil, ErrEmptyLink
	}

	action := NewAction()
	pid, _ := mongo.ParseObjectID(routine.CurrentActionID)
	action.SetID(data.ID(pid.Hex()))
	return action, store.PopulateByID(action)

}

func (routine *Routine) IncludeTask(task *Task) {
	routine.TasksIDs = append(routine.TasksIDs, task.ID().String())
}

func (routine *Routine) ExcludeTask(task *Task) {
	tmp := make([]string, 0)
	id := task.ID().String()
	for _, s := range routine.TasksIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	routine.TasksIDs = tmp
}

func (routine *Routine) TasksIter(store data.Store) (data.ModelIterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.TasksIDs), store), nil
}

func (routine *Routine) Tasks(store data.Store) ([]*Task, error) {

	tasks := make([]*Task, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.TasksIDs), store)
	task := NewTask()
	for iter.Next(task) {
		tasks = append(tasks, task)
		task = NewTask()
	}
	return tasks, nil
}

func (routine *Routine) SetUser(user *User) error {
	routine.UserID = user.ID().String()
	return nil
}

func (routine *Routine) User(store data.Store) (*User, error) {
	if routine.UserID == "" {
		return nil, ErrEmptyLink
	}

	user := NewUser()
	pid, _ := mongo.ParseObjectID(routine.UserID)
	user.SetID(data.ID(pid.Hex()))
	return user, store.PopulateByID(user)

}

func (routine *Routine) GetBSON() (interface{}, error) {

	return struct {
		CreatedAt *time.Time `json:"created_at" bson:"created_at"`

		EndTime *time.Time `json:"end_time" bson:"end_time"`

		Id string `json:"id" bson:"_id,omitempty"`

		Name string `json:"name" bson:"name"`

		StartTime *time.Time `json:"start_time" bson:"start_time"`

		UpdatedAt *time.Time `json:"updated_at" bson:"updated_at"`

		ActionsIDs []string `json:"actions_ids" bson:"actions_ids"`

		CompletedTasksIDs []string `json:"completed_tasks_ids" bson:"completed_tasks_ids"`

		CurrentActionID string `json:"current_action_id" bson:"current_action_id"`

		TasksIDs []string `json:"tasks_ids" bson:"tasks_ids"`

		UserID string `json:"user_id" bson:"user_id"`
	}{

		CreatedAt: routine.CreatedAt,

		EndTime: routine.EndTime,

		Name: routine.Name,

		StartTime: routine.StartTime,

		UpdatedAt: routine.UpdatedAt,

		ActionsIDs: routine.ActionsIDs,

		CompletedTasksIDs: routine.CompletedTasksIDs,

		CurrentActionID: routine.CurrentActionID,

		TasksIDs: routine.TasksIDs,

		UserID: routine.UserID,
	}, nil

}

func (routine *Routine) SetBSON(raw bson.Raw) error {

	tmp := struct {
		CreatedAt *time.Time `json:"created_at" bson:"created_at"`

		EndTime *time.Time `json:"end_time" bson:"end_time"`

		Id bson.ObjectId `json:"id" bson:"_id,omitempty"`

		Name string `json:"name" bson:"name"`

		StartTime *time.Time `json:"start_time" bson:"start_time"`

		UpdatedAt *time.Time `json:"updated_at" bson:"updated_at"`

		ActionsIDs []string `json:"actions_ids" bson:"actions_ids"`

		CompletedTasksIDs []string `json:"completed_tasks_ids" bson:"completed_tasks_ids"`

		CurrentActionID string `json:"current_action_id" bson:"current_action_id"`

		TasksIDs []string `json:"tasks_ids" bson:"tasks_ids"`

		UserID string `json:"user_id" bson:"user_id"`
	}{}

	err := raw.Unmarshal(&tmp)
	if err != nil {
		return err
	}

	routine.CreatedAt = tmp.CreatedAt

	routine.EndTime = tmp.EndTime

	routine.Id = tmp.Id.Hex()

	routine.Name = tmp.Name

	routine.StartTime = tmp.StartTime

	routine.UpdatedAt = tmp.UpdatedAt

	routine.ActionsIDs = tmp.ActionsIDs

	routine.CompletedTasksIDs = tmp.CompletedTasksIDs

	routine.CurrentActionID = tmp.CurrentActionID

	routine.TasksIDs = tmp.TasksIDs

	routine.UserID = tmp.UserID

	return nil

}
