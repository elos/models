package models

import (
	"time"

	"github.com/elos/data"
	"github.com/elos/data/builtin/mongo"
	"gopkg.in/mgo.v2/bson"
)

// THIS FILE GENERATED BY METIS

// this type def generated by metis
type Routine struct {
	ActionsIDs        []string  `json:"actions_ids" bson:"actions_ids"`
	CompletedTasksIDs []string  `json:"completed_tasks_ids" bson:"completed_tasks_ids"`
	CreatedAt         time.Time `json:"created_at" bson:"created_at"`
	CurrentActionID   string    `json:"current_action_id" bson:"current_action_id"`
	EndTime           time.Time `json:"end_time" bson:"end_time"`
	Id                string    `json:"id" bson:"_id,omitempty"`
	Name              string    `json:"name" bson:"name"`
	OwnerID           string    `json:"owner_id" bson:"owner_id"`
	PersonID          string    `json:"person_id" bson:"person_id"`
	StartTime         time.Time `json:"start_time" bson:"start_time"`
	TasksIDs          []string  `json:"tasks_ids" bson:"tasks_ids"`
	UpdatedAt         time.Time `json:"updated_at" bson:"updated_at"`
}

func NewRoutine() *Routine {
	return &Routine{}
}

func FindRoutine(db data.DB, id data.ID) (*Routine, error) {

	routine := NewRoutine()
	routine.SetID(id)

	return routine, db.PopulateByID(routine)

}

// Kind is derived from the models package and is
// defined in type.go, shared among implementations
func (routine *Routine) Kind() data.Kind {
	return RoutineKind
}

// just returns itself for now
func (routine *Routine) Concerned() []data.ID {
	foo := make([]data.ID, 1)
	foo[0] = routine.ID()
	return foo
}

func (routine *Routine) SetID(id data.ID) {
	routine.Id = id.String()
}

func (routine *Routine) ID() data.ID {
	return data.ID(routine.Id)
}

func (routine *Routine) IncludeAction(action *Action) {
	routine.ActionsIDs = append(routine.ActionsIDs, action.ID().String())
}

func (routine *Routine) ExcludeAction(action *Action) {
	tmp := make([]string, 0)
	id := action.ID().String()
	for _, s := range routine.ActionsIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	routine.ActionsIDs = tmp
}

func (routine *Routine) ActionsIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.ActionsIDs), db), nil
}

func (routine *Routine) Actions(db data.DB) ([]*Action, error) {

	actions := make([]*Action, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.ActionsIDs), db)
	action := NewAction()
	for iter.Next(action) {
		actions = append(actions, action)
		action = NewAction()
	}
	return actions, nil
}

func (routine *Routine) IncludeCompletedTask(completedTask *Task) {
	routine.CompletedTasksIDs = append(routine.CompletedTasksIDs, completedTask.ID().String())
}

func (routine *Routine) ExcludeCompletedTask(completedTask *Task) {
	tmp := make([]string, 0)
	id := completedTask.ID().String()
	for _, s := range routine.CompletedTasksIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	routine.CompletedTasksIDs = tmp
}

func (routine *Routine) CompletedTasksIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.CompletedTasksIDs), db), nil
}

func (routine *Routine) CompletedTasks(db data.DB) ([]*Task, error) {

	completed_tasks := make([]*Task, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.CompletedTasksIDs), db)
	completed_task := NewTask()
	for iter.Next(completed_task) {
		completed_tasks = append(completed_tasks, completed_task)
		completed_task = NewTask()
	}
	return completed_tasks, nil
}

func (routine *Routine) SetCurrentAction(actionArgument *Action) error {
	routine.CurrentActionID = actionArgument.ID().String()
	return nil
}

func (routine *Routine) CurrentAction(db data.DB) (*Action, error) {
	if routine.CurrentActionID == "" {
		return nil, ErrEmptyLink
	}

	actionArgument := NewAction()
	pid, _ := mongo.ParseObjectID(routine.CurrentActionID)
	actionArgument.SetID(data.ID(pid.Hex()))
	return actionArgument, db.PopulateByID(actionArgument)

}

func (routine *Routine) CurrentActionOrCreate(db data.DB) (*Action, error) {
	action, err := routine.CurrentAction(db)

	if err == ErrEmptyLink {
		action := NewAction()
		action.SetID(db.NewID())
		if err := routine.SetCurrentAction(action); err != nil {
			return nil, err
		}

		if err := db.Save(action); err != nil {
			return nil, err
		}

		if err := db.Save(routine); err != nil {
			return nil, err
		}

		return action, nil
	} else {
		return action, err
	}
}

func (routine *Routine) SetOwner(userArgument *User) error {
	routine.OwnerID = userArgument.ID().String()
	return nil
}

func (routine *Routine) Owner(db data.DB) (*User, error) {
	if routine.OwnerID == "" {
		return nil, ErrEmptyLink
	}

	userArgument := NewUser()
	pid, _ := mongo.ParseObjectID(routine.OwnerID)
	userArgument.SetID(data.ID(pid.Hex()))
	return userArgument, db.PopulateByID(userArgument)

}

func (routine *Routine) OwnerOrCreate(db data.DB) (*User, error) {
	user, err := routine.Owner(db)

	if err == ErrEmptyLink {
		user := NewUser()
		user.SetID(db.NewID())
		if err := routine.SetOwner(user); err != nil {
			return nil, err
		}

		if err := db.Save(user); err != nil {
			return nil, err
		}

		if err := db.Save(routine); err != nil {
			return nil, err
		}

		return user, nil
	} else {
		return user, err
	}
}

func (routine *Routine) SetPerson(personArgument *Person) error {
	routine.PersonID = personArgument.ID().String()
	return nil
}

func (routine *Routine) Person(db data.DB) (*Person, error) {
	if routine.PersonID == "" {
		return nil, ErrEmptyLink
	}

	personArgument := NewPerson()
	pid, _ := mongo.ParseObjectID(routine.PersonID)
	personArgument.SetID(data.ID(pid.Hex()))
	return personArgument, db.PopulateByID(personArgument)

}

func (routine *Routine) PersonOrCreate(db data.DB) (*Person, error) {
	person, err := routine.Person(db)

	if err == ErrEmptyLink {
		person := NewPerson()
		person.SetID(db.NewID())
		if err := routine.SetPerson(person); err != nil {
			return nil, err
		}

		if err := db.Save(person); err != nil {
			return nil, err
		}

		if err := db.Save(routine); err != nil {
			return nil, err
		}

		return person, nil
	} else {
		return person, err
	}
}

func (routine *Routine) IncludeTask(task *Task) {
	routine.TasksIDs = append(routine.TasksIDs, task.ID().String())
}

func (routine *Routine) ExcludeTask(task *Task) {
	tmp := make([]string, 0)
	id := task.ID().String()
	for _, s := range routine.TasksIDs {
		if s != id {
			tmp = append(tmp, s)
		}
	}
	routine.TasksIDs = tmp
}

func (routine *Routine) TasksIter(db data.DB) (data.Iterator, error) {
	// not yet completely general
	return mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.TasksIDs), db), nil
}

func (routine *Routine) Tasks(db data.DB) ([]*Task, error) {

	tasks := make([]*Task, 0)
	iter := mongo.NewIDIter(mongo.NewIDSetFromStrings(routine.TasksIDs), db)
	task := NewTask()
	for iter.Next(task) {
		tasks = append(tasks, task)
		task = NewTask()
	}
	return tasks, nil
}

// BSON {{{
func (routine *Routine) GetBSON() (interface{}, error) {

	return struct {
		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		EndTime time.Time `json:"end_time" bson:"end_time"`

		Id string `json:"id" bson:"_id,omitempty"`

		Name string `json:"name" bson:"name"`

		StartTime time.Time `json:"start_time" bson:"start_time"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		ActionsIDs []string `json:"actions_ids" bson:"actions_ids"`

		CompletedTasksIDs []string `json:"completed_tasks_ids" bson:"completed_tasks_ids"`

		CurrentActionID string `json:"current_action_id" bson:"current_action_id"`

		OwnerID string `json:"owner_id" bson:"owner_id"`

		PersonID string `json:"person_id" bson:"person_id"`

		TasksIDs []string `json:"tasks_ids" bson:"tasks_ids"`
	}{

		CreatedAt: routine.CreatedAt,

		EndTime: routine.EndTime,

		Name: routine.Name,

		StartTime: routine.StartTime,

		UpdatedAt: routine.UpdatedAt,

		ActionsIDs: routine.ActionsIDs,

		CompletedTasksIDs: routine.CompletedTasksIDs,

		CurrentActionID: routine.CurrentActionID,

		OwnerID: routine.OwnerID,

		PersonID: routine.PersonID,

		TasksIDs: routine.TasksIDs,
	}, nil

}

func (routine *Routine) SetBSON(raw bson.Raw) error {

	tmp := struct {
		CreatedAt time.Time `json:"created_at" bson:"created_at"`

		EndTime time.Time `json:"end_time" bson:"end_time"`

		Id bson.ObjectId `json:"id" bson:"_id,omitempty"`

		Name string `json:"name" bson:"name"`

		StartTime time.Time `json:"start_time" bson:"start_time"`

		UpdatedAt time.Time `json:"updated_at" bson:"updated_at"`

		ActionsIDs []string `json:"actions_ids" bson:"actions_ids"`

		CompletedTasksIDs []string `json:"completed_tasks_ids" bson:"completed_tasks_ids"`

		CurrentActionID string `json:"current_action_id" bson:"current_action_id"`

		OwnerID string `json:"owner_id" bson:"owner_id"`

		PersonID string `json:"person_id" bson:"person_id"`

		TasksIDs []string `json:"tasks_ids" bson:"tasks_ids"`
	}{}

	err := raw.Unmarshal(&tmp)
	if err != nil {
		return err
	}

	routine.CreatedAt = tmp.CreatedAt

	routine.EndTime = tmp.EndTime

	routine.Id = tmp.Id.Hex()

	routine.Name = tmp.Name

	routine.StartTime = tmp.StartTime

	routine.UpdatedAt = tmp.UpdatedAt

	routine.ActionsIDs = tmp.ActionsIDs

	routine.CompletedTasksIDs = tmp.CompletedTasksIDs

	routine.CurrentActionID = tmp.CurrentActionID

	routine.OwnerID = tmp.OwnerID

	routine.PersonID = tmp.PersonID

	routine.TasksIDs = tmp.TasksIDs

	return nil

}

// BSON }}}
